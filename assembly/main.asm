;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   —б фев 29 2020
; Processor: ATtiny85
; Compiler:  AVRASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================

; Even though the AVR initializes the Stack Pointer to RAM end at startup, it's good for practice to make sure it's there :D

.EQU RAMEND = 0x25F ; Define RAM end
.EQU SPH = 0x3E ; Define Stack Pointer high byte
.EQU SPL = 0x3D ; Define Stack Pointer low byte

;====================================================================
; VARIABLES
;====================================================================

.EQU DDRB = 0x17	; DDRB address in the I/O memory space
.EQU PORTB = 0x18 ; PORTB address in the I/O memory space

; Define PB pins
.EQU PB0 = 0x00
.EQU PB1 = 0x01
.EQU PB2 = 0x02
.EQU PB3 = 0x03
.EQU PB4 = 0x04

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

.CSEG	; Code segment
.ORG 0x00 ; Start at memory location 0x00, RESET vector
		RJMP  Start

;====================================================================
; CODE SEGMENT
;====================================================================

Start:
	LDI R17, high(RAMEND)	; Load high byte of RAM end to R17
	LDI R16, low(RAMEND)		; Load low byte to R16

	OUT SPH, R17	; Load SP high byte with RAM end high byte
	OUT SPL, R16	; Load SP low byte with RAM end low byte
	
	SBI DDRB, PB0	; Set PB0 as output
	
Loop:

	SBI PORTB, PB0	; High (Set bit)
	RCALL Delay	; Delay 1s
	CBI PORTB, PB0	; Low (Clear bit)
	RCALL Delay	; Delay 1s
	
	RJMP  Loop

;====================================================================
; SUBROUTINES
;====================================================================

; Calculate delay with overhead:
; First loop: [ (1 + 1 + 2) * 249 ] - 1 = 995 cycles
; Second loop: [ (995 + 1 + 1 + 2) * 200 ] - 1 = 199,799 cycles
; Third loop: [ (199,799 + 1 + 1 + 2) * 5 ] - 1 = 999,014? cycles
; Overhead = 999,014 + 3 + 1 + 4 = 999,022 cycles * 1us = 999,022us ~ 1s

Delay:	; Delay subroutine,
		
		
		LDI R18, 0x05
D3:	LDI R17, 0xC8
D2:	LDI R16, 0xF9 ; Load Immediate constant into General Purpose Register (GPR) 16       *(LDI works on GPRs 16 - 31)
D1:	DEC R16	; Decrement GPR 16
		NOP	; No operation (adds 1 clock cycle)
		BRNE D1	; Branch back if not zero
		; First loop: [ (1 + 1 + 2) * 249 ] - 1 = 995 cycles

		DEC R17
		BRNE D2
		; Second loop: [ (995 + 1 + 1 + 2) * 200 ] - 1 = 199,799 cycles
		
		DEC R18
		BRNE D3
		; Third loop: [ (199,799 + 1 + 1 + 2) * 5 ] - 1 = 999,014? cycles
		
	RET	; Return from subroutine

;====================================================================
